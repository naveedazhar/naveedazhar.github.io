# 3. Object-Oriented Programming

It's important to know how each of the paradigms work and how they urge you to structure the code within them, but with respect to architecture, Object-Oriented Programming is the clear _tool for the job_.

Not only does Object-Oriented programming enable us to create a **plugin architecture** and build flexibility into our projects; OOP comes with the 4 principles of OOP (encapsulation, inheritance, polymorhism, and abstraction) that help us create **rich domain models**.

Most developers learning Object-Oriented Programming never get to this part: learning how to create a software implementation of the problem domain, and locating it in the center of a **layered** web app.

Functional programming can seem like the means to all ends in this scenario, but I'd recommend getting acquainted with model-driven design and [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) to understand the bigger picture on how object-modelers are able to encapsulate an entire business in a zero-dependency domain model.

> Why is that a huge deal?

It's huge because if you can create a mental-model of a business, you can create a software implementation of that business.
